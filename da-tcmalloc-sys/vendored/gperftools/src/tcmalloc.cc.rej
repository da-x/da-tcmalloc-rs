--- src/tcmalloc.cc
+++ src/tcmalloc.cc
@@ -189,32 +192,6 @@ DECLARE_double(tcmalloc_release_rate);
 #define TC_ALIAS(name) __attribute__((alias(#name)))
 #endif
 
-// For windows, the printf we use to report large allocs is
-// potentially dangerous: it could cause a malloc that would cause an
-// infinite loop.  So by default we set the threshold to a huge number
-// on windows, so this bad situation will never trigger.  You can
-// always set TCMALLOC_LARGE_ALLOC_REPORT_THRESHOLD manually if you
-// want this functionality.
-#ifdef _WIN32
-const int64 kDefaultLargeAllocReportThreshold = static_cast<int64>(1) << 62;
-#else
-const int64 kDefaultLargeAllocReportThreshold = static_cast<int64>(1) << 30;
-#endif
-DEFINE_int64(tcmalloc_large_alloc_report_threshold,
-             EnvToInt64("TCMALLOC_LARGE_ALLOC_REPORT_THRESHOLD",
-                        kDefaultLargeAllocReportThreshold),
-             "Allocations larger than this value cause a stack "
-             "trace to be dumped to stderr.  The threshold for "
-             "dumping stack traces is increased by a factor of 1.125 "
-             "every time we print a message so that the threshold "
-             "automatically goes up by a factor of ~1000 every 60 "
-             "messages.  This bounds the amount of extra logging "
-             "generated by this flag.  Default value of this flag "
-             "is very large and therefore you should see no extra "
-             "logging unless the flag is overridden.  Set to 0 to "
-             "disable reporting entirely.");
-
-
 // We already declared these functions in tcmalloc.h, but we have to
 // declare them again to give them an ATTRIBUTE_SECTION: we want to
 // put all callers of MallocHook::Invoke* in this module into
@@ -1369,46 +1442,95 @@ void* handle_oom(malloc_fn retry_fn,
   }
 }
 
-// Copy of FLAGS_tcmalloc_large_alloc_report_threshold with
-// automatic increases factored in.
-static int64_t large_alloc_threshold =
-  (kPageSize > FLAGS_tcmalloc_large_alloc_report_threshold
-   ? kPageSize : FLAGS_tcmalloc_large_alloc_report_threshold);
-
 static void ReportLargeAlloc(Length num_pages, void* result) {
   StackTrace stack;
-  stack.depth = GetStackTrace(stack.stack, tcmalloc::kMaxStackDepth, 1);
+  stack.depth = tcmalloc::GrabBacktrace(stack.stack, tcmalloc::kMaxStackDepth, 1);
 
   static const int N = 1000;
   char buffer[N];
   TCMalloc_Printer printer(buffer, N);
   printer.printf("tcmalloc: large alloc %" PRIu64 " bytes == %p @ ",
-                 static_cast<uint64>(num_pages) << kPageShift,
+                 static_cast<uint64_t>(num_pages) << kPageShift,
                  result);
   for (int i = 0; i < stack.depth; i++) {
     printer.printf(" %p", stack.stack[i]);
   }
   printer.printf("\n");
-  write(STDERR_FILENO, buffer, strlen(buffer));
+  auto unused = write(STDERR_FILENO, buffer, strlen(buffer));
+  (void)unused;
 }
 
-// Must be called with the page lock held.
-inline bool should_report_large(Length num_pages) {
-  const int64 threshold = large_alloc_threshold;
-  if (threshold > 0 && num_pages >= (threshold >> kPageShift)) {
-    // Increase the threshold by 1/8 every time we generate a report.
-    // We cap the threshold at 8GiB to avoid overflow problems.
-    large_alloc_threshold = (threshold + threshold/8 < 8ll<<30
-                             ? threshold + threshold/8 : 8ll<<30);
-    return true;
+static bool should_report_large(Length num_pages) {
+#ifdef ENABLE_LARGE_ALLOC_REPORT
+// For windows, the printf we use to report large allocs is
+// potentially dangerous: it could cause a malloc that would cause an
+// infinite loop.  So by default we set the threshold to a huge number
+// on windows, so this bad situation will never trigger.  You can
+// always set TCMALLOC_LARGE_ALLOC_REPORT_THRESHOLD manually if you
+// want this functionality.
+#ifdef _WIN32
+  constexpr auto kDefaultLargeAllocReportThreshold = int64_t{1} << 62;
+#else
+  constexpr auto kDefaultLargeAllocReportThreshold = int64_t{1} << 30;
+#endif
+
+  // Note, our 'reporting threshold setting' is 64-bit, but we can
+  // only afford size_t threshold variable. I.e. some 32-bit machines
+  // don't support 64-bit atomics. So some care is taken to cast etc.
+  static std::atomic<size_t> large_alloc_threshold;
+  size_t threshold = large_alloc_threshold.load(std::memory_order_relaxed);
+
+  if (threshold == 0) {
+    int64_t value = tcmalloc::commandlineflags::StringToLongLong(
+      TCMallocGetenvSafe("TCMALLOC_LARGE_ALLOC_REPORT_THRESHOLD"),
+      kDefaultLargeAllocReportThreshold);
+    if (value < 0) {
+      // Negative limit means disable reporting
+      value = std::numeric_limits<size_t>::max();
+    }
+    value = std::max<int64_t>(kPageSize, value);
+
+    if (sizeof(size_t) < sizeof(int64_t)) {
+      // On 32-bit machines size_t is narrower than int64_t. So lets
+      // make limits larger than size_t's max (i.e. overflowing 32-bit
+      // unsigned int) to be infinity.
+      value = std::min<int64_t>(value, std::numeric_limits<size_t>::max());
+    }
+
+    threshold = static_cast<ssize_t>(value);
+    large_alloc_threshold.store(threshold); // harmless to race
   }
+
+  do {
+    if (PREDICT_TRUE(num_pages < (threshold >> kPageShift))) {
+      return false;
+    }
+
+    // Increase the threshold by 1/8 every time we generate a report.
+    size_t new_threshold = threshold + threshold / 8;
+    if (new_threshold < threshold) {
+      new_threshold = std::numeric_limits<size_t>::max();
+    }
+
+    // Also make new threshold at least as big as the allocation that
+    // triggered the reporting.
+    new_threshold = std::max<size_t>(new_threshold,
+                                     num_pages << kPageShift);
+
+    if (large_alloc_threshold.compare_exchange_strong(
+          threshold, new_threshold,
+          std::memory_order_relaxed, std::memory_order_relaxed)) {
+      return true;
+    }
+  } while (true);
+
+#endif
   return false;
 }
 
 // Helper for do_malloc().
 static void* do_malloc_pages(ThreadCache* heap, size_t size) {
   void* result;
-  bool report_large;
 
   Length num_pages = tcmalloc::pages(size);
 
